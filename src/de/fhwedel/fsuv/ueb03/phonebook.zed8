This specification describes Phonebook

â”€ [ NAME, PHONE ] â””

State space

â”Œ PhoneBook
  known :  ð”½ NAME
  tel : NAME â‡¸ PHONE
|
  known = dom tel
â””
dom macht "zweiseitige Bindung" -> Manipulation an known/tel bewirkt Manipulation tel/known

Initialization

â”Œ InitPhoneBook
 PhoneBook â€²
|
  telâ€² = âˆ…
â””


Operations

The good parts

Zustansschema aber keine Operation (es wird nichts verÃ¤ndert)
â”Œ lookup
  ÎžPhoneBook
  name? : NAME
  phone! : PHONE
|
  name? âˆˆ known
  phone! = tel(name?)
â””

Operation -> hat Zustand der verÃ¤ndert wird
â”Œ addName
  Î”PhoneBook
  name? : NAME
  phone? : PHONE
|
  name? âˆ‰ known
  
  telâ€² = tel âˆª { name? â†¦ phone? } 
â””
KÃ¶nnte man auch mit: known' = known \ { name? } machen

Operation
â”Œ delName
  Î”PhoneBook
  name? : NAME
|
  name? âˆˆ known
  
  telâ€² = tel âˆ– { name? â†¦ tel(name?) }
â””


Error handling

â”€
  REPORT ::= okay | name_not_known | name_already_known
â””

Nur Schema (kein Zustandsschema und auch keine Operation)
â”Œ Success
  rep! : REPORT
|
  rep! = okay
â””

Zustandsschema
â”Œ NotKnown
  ÎžPhoneBook
  name? : NAME
  rep! : REPORT
|
  name? âˆ‰ known
  rep! = name_not_known
â””

Zustandsschema
â”Œ AlreadyKnown
  ÎžPhoneBook
  name? : NAME
  rep! : REPORT
|
  name? âˆˆ known
  rep! = name_already_known
â””

Robust Operations

â”€
  DoFindOp  == (lookup âˆ§ Success)  âˆ¨ NotKnown
â””

â”€
  DoAddName  == (addName âˆ§ Success) âˆ¨AlreadyKnown
â””

â”€
  DoDelName  == (delName âˆ§ Success) âˆ¨ NotKnown
â””
